
## 요청과 응답 - 인터넷을 통한 데이터 전송

인터넷에서 웹사이트에 접속하기 위해서는 두가지 핵심 과정이 있다. 요청(request)와 응답(response)이다. 우리가 웹브라우저를 통해 어떤 웹사이트에 접속한다고 생각해 보자. 우리는 주소창에 접속하고자 하는 URL을 입력한다. 그리고 그 URL이 올바르다면 브라우저에 웹페이지가 보여진다.

만약 재미있는 웹 페이지를 접속했다면, 해당 웹 페이지에 눈이 쏠리며 탐독하고 싶은 욕심이 생기겠지만, 잠시 그 욕구를 멈추고 좀더 기술적인 관점에서 바라보도록 하자. 우리가 바라보는 이 웹사이트의 실체는 무엇일까?

이 웹 페이지에서 시각적인 요소를 배제하고, 단지 웹브라우저를 통해 어떤 작용이 일어났다고 생각해 보자. 어떤 일이 일어났길래 대관절, 이렇게 웹사이트가 우리 앞에 나타나게 되는 걸까?

## 직접 경험하는 요청과 응답

우선 우리가 보는 웹사이트는 웹사이트가 HTML 문서를 보고, 이 문서의 지시에 따라 화면에 그려낸 결과물이다. 여기서 우리는 DOM이라는 것을 만나게 된다. DOM은 웹브라우저가 화면에 그릴 웹 페이지의 정보를 담고 있다. 이 DOM은 HTML 문서를 파싱하여 이루어진다.

HTML 문서는 서버의 응답을 통해 얻는다. 이 응답은 웹브라우저에서 주소를 치는 순간, 웹브라우저가 서버에 절절한 요청하기 때문이다.


### HTML 문서 만들기

우리는 우리가 해 볼 수 있는 요청의 가장 밑바닥부터 시작해 보고자 한다. 다음과 같이 html 문서를 적절한 디렉토리에 생성해 보자.
```html
# index.html

<!DOCTYPE html>
<html lang="en">
<body>
<h1>Hello, World!</h1>
</body>
</html>
```


### 웹서버 구동하기

 PHP가 설치되어 있다면 바로 웹서버를 동작해 볼 수 있다. 작업한 디렉토리에서 아래 명령을 입력해 보자. 
```shell
php -S 127.0.0.1:8000
```

웹서버를 구동할 수 있는 방법은 여럿 있다. 이외에 적절한 방법으로 웹서버를 구동해도 관계 없다. 웹브라우저를 통해 'http://127.0.0.1:8000/' 을 접속해 보자. Hello, World! 가 나올 것이다.


### 텔넷으로 접속하기

이제 우리는 텔넷을 이용한다. 웹브라우저가 간편하게 작업해 주던 것을 조금 불편하지만 직접 손으로 하나하나 작업해 볼 것이다.

1. 명령어 `telnet 127.0.0.1 8000`을 입력한다.
2. `Escape character is '^]'.`라는 메시지가 출력되고, 커서가 입력 대기 중인 것을 확인한다.
3. 아래와 같이 명령을 한줄씩 입력한다. 불편하겠지만 오타 없이 주의 깊게 입력하도록 ㅎ자.
   ```
   GET / HTTP/1.1
   Host: 127.0.0.1:8000
   User-Agent: my-fingers/1.0.0
   Accept: */*
   ```
4. 그다음 엔터를 두 번 입력한다. 

모든 것이 올바르게 입력되었다면 아래와 같은 텍스트가 출력될 것이다.
```
HTTP/1.1 200 OK
Host: 127.0.0.1:8000
Date: Thu, 15 Aug 2024 12:48:52 GMT
Connection: close
Content-Type: text/html; charset=UTF-8
Content-Length: 79

<!DOCTYPE html>
<html lang="en">
<body>
<h1>Hello, World!</h1>
</body>
</html>
Connection closed by foreign host.
```

## 내가 뭘 한 거지?

웹브라우저가 간단하게 해 주던 것을 모두 손으로 하나하나 일일이 실행해 본 것이다. 이 아래로 TCP/IP 통신 등 더 넓은 주제로도 이야기가 심화될 수 있지만, 너무 이야기가 장황해지니 너무 자세하게는 다루지 않는다. 아무튼 내 PC에서 직접 서버를 구동하고, 내 PC에서 직접 해당 서버에 접속을 해 본 것이다. 비유하자면 전화기를 집 거실과 주방에 각각 하나씩 두고 거실에서 주방으로 전화를 걸어 본 것이다. 두 전화기의 거리가 가까운 집 안이 아니라 멀리 떨어진 어떤 두 장소라고 생각해 보자. 일반적인 전화 통화가 될 것이다. 마찬가지로 서버가 내 PC가 아닌 집 밖 세상 어딘가 구동 중인 일반적인 서버라고 생각해 보자.

그리고 그 웹 서버에 웹페이지를 달라는 요청을 직접 손으로 적어 넣었다.
- 첫 줄 `GET / HTTP/1.1`을 살펴 보자.
	- HTTP 요청 방법 중 가장 일반적인 'GET' 방식을 사용하겠다는 의미이다.
	- `HTTP/1.1`은 HTTP 프로토콜 버전 1.1을 사용하겠다는 의미이다.
- 둘째 줄부터 HTTP 요청 헤더 메시지를 직접 작성하였다.
	- `Host: 127.0.0.1:8000`
		- 요청하는 호스트가 `127.0.0.1:8000`임을 명시하였다.
		- 같은 IP, 혹은 한 대의 서버로 여러 웹사이트를 운영할 수 있다.
		- 이 때 도메인으로 서로 다른 웹사이트를 식별할 수 있게 된다.
	- `User-Agent: my-fingers/1.0.0`
		- 선택적으로 접속하는 쪽의 정보를 알려줄 수 있다.
		- 직접 손으로 작성하니, 'my-fingers'라는 애교섞인 문자열을 보내 보았다. 무엇이라도 상관은 없다만, 실제 웹브라우저들은 꽤 자세한 정보를 전송한다. 예를 들어 `Mozilla/5.0 (X11; Linux x86_64; rv:129.0) Gecko/20100101 Firefox/129.0`는 현재 필자가 사용하는 브라우저의 User-Agent 헤더 값이다. 웹브라우저의 종류, 버전, 사용중인 OS 까지 정보를 보내 준다.
	- `Accept: */*`
		- 어떤 형태의 응답도 받을 수 있다는 의미이다.
		- 여기서 값은 MIME 형식을 따른다. `text/html`, `application/json` 같은 문자열들이다. 실제 웹브라우저는 아래와 같이 좀 더 복잡한 값을 사용한다.
- 두번의 줄바꿈이 일어나면 헤더 전송이 끝나며, HTTP 요청이 끝난다. 요청이 올바르다면 서버로부터 응답이 수신된다.

이제 응답 메시지를 살펴보자.

- 응답의 처음은 `HTTP/1.1 200 OK`이다.
	- HTTP/1.1 방식으로 응답이 전달된다.
	- 상태값 `200`을 받았다. 200은 정상 수신이라는 뜻이다.
	- `OK`는 상태값 `200`에 대한 설명이다.
- 이후 두번의 줄바꿈이 있을 때까지 모두 응답 헤더이다.
	- 요청한 호스트로부터 응답을 수신했다.
	- 응답의 시간, 문서의 종류, 길이 등의 정보를 수신했다.
- 헤더가 끝난 후, 작성했던 본문 HTML 문서를 그대로 받았다.

### 이후의 과정
이렇게 전달받은 HTML 로는 어떤 내용을 보낸 것인지 사람이 보기 어렵다. 이 다음 웹브라우저는 HTML 문서를 해석하는 과정을 거치게 되는데, 이를 파싱(pasing)한다고 표현하기도 한다. 파싱을 거친 후 웹브라우저는 DOM (Document Object Model)이라고 하는 객체를 만들게 된다.

DOM 객체를 만들고 난 후, 이것을 화면에 그려 내는 작업을 할 수 있게 된다. 이것을 렌더링(rendering)이라고 한다. 지금이야 h1 태그 정도를 사용한 단순한 문서이기 때문에 사람이 보더라도 직관적으로 내용을 추측할 수 있지만, 보다 복잡한 웹페이지 문서라면 이렇게 렌더링을 거쳐야만 이해할 수 있는 모양이 될 것이다.

웹브라우저의 성능은 지금까지 언급되었던 작업을 얼마나 정확하고 빠르게, 편리하게, 그리고 안전하게 해 낼 수 있느냐로 측정된다. 현재도 많은 웹브라우저들은 이 작업을 더욱 개선하기 위해 노력중이다.


> 아래는 ChatGPT를 통해,
### 인터넷 요청과 응답: 기본 개념

인터넷에서 웹사이트를 이용하기 위해서는 두 가지 핵심 과정이 있습니다: **요청**과 **응답**입니다. 이 과정은 웹 브라우저와 웹 서버 간의 통신을 통해 이루어집니다.
#### 1. 요청(Request)이란?

웹 브라우저를 통해 웹사이트를 방문할 때, 브라우저는 웹 서버에 **요청(Request)**을 보냅니다. 요청은 사용자가 보고자 하는 웹 페이지나 자원을 서버에 요청하는 것을 의미합니다.

- **URL 입력**: 사용자가 웹 브라우저의 주소창에 웹사이트의 URL(Uniform Resource Locator)을 입력하거나 링크를 클릭합니다.
- **요청 생성**: 브라우저는 HTTP(Hypertext Transfer Protocol) 또는 HTTPS(Hypertext Transfer Protocol Secure) 프로토콜을 사용하여 해당 URL에 대한 요청을 생성합니다. 이 요청은 서버가 응답할 수 있도록 필요한 정보를 포함합니다.
- **요청 전송**: 요청은 인터넷을 통해 서버에 전송됩니다. 이 과정에서 DNS(Domain Name System) 서버가 도메인 이름을 IP 주소로 변환하여, 브라우저가 정확한 서버에 접근할 수 있게 도와줍니다.

#### 2. 응답(Response)이란?

웹 서버는 브라우저로부터 요청을 수신하면, **응답(Response)**을 생성하여 브라우저로 보냅니다. 응답은 요청된 웹 페이지의 내용을 포함하며, 브라우저가 페이지를 표시할 수 있도록 돕습니다.

- **서버의 처리**: 서버는 요청을 처리하고, 필요한 자원(예: HTML 파일, 이미지, 스타일 시트, 자바스크립트 파일 등)을 찾습니다. 서버가 처리한 결과를 응답으로 준비합니다.
- **응답 생성**: 서버는 요청된 정보와 함께 상태 코드를 포함한 응답을 생성합니다. 상태 코드는 요청 처리 결과를 나타내며, 예를 들어 `200 OK`는 요청이 성공적으로 처리되었음을, `404 Not Found`는 요청한 페이지를 찾을 수 없음을 의미합니다.
- **응답 전송**: 생성된 응답은 브라우저로 전송됩니다. 응답은 HTML, CSS, 자바스크립트, 이미지 파일 등 웹 페이지를 구성하는 요소들을 포함할 수 있습니다.

#### 3. 요청과 응답의 흐름

1. **요청**: 사용자가 브라우저를 통해 웹사이트에 접속하려고 할 때, 브라우저는 웹 서버에 요청을 보냅니다.
2. **서버 처리**: 서버는 요청을 수신하고, 필요한 자원을 준비합니다.
3. **응답**: 서버는 요청에 대한 응답을 브라우저로 보내며, 이 응답은 요청된 웹 페이지의 내용을 포함합니다.
4. **페이지 렌더링**: 브라우저는 서버로부터 받은 응답을 처리하여 화면에 웹 페이지를 렌더링합니다.

#### 4. 상태 코드

응답에는 상태 코드가 포함됩니다. 이 코드는 요청의 처리 상태를 나타내며, 다음과 같은 코드가 자주 사용됩니다:

- **200 OK**: 요청이 성공적으로 처리되었음을 의미합니다.
- **404 Not Found**: 요청한 페이지를 찾을 수 없음을 의미합니다.
- **500 Internal Server Error**: 서버 내부에서 오류가 발생했음을 의미합니다.

이러한 요청과 응답 과정은 사용자가 웹사이트를 방문하고 정보를 얻는 데 필수적인 요소입니다. 웹의 기본 작동 방식을 이해하는 것은 웹 개발이나 디지털 환경에서의 문제 해결에 도움이 됩니다.